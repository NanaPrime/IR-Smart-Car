// Author:  Hannah R. Huron
// Date:    May 07, 2025
// Subject: IR Smart Car
// Class:   Microcomputer Systems I Final Project

// READ ME
// This is a car designed to follow a black line, be it tape or otherwise. It is 
// constructed using 3D printed filament for the body, jumper wires, a PIC16F1829 board 
// that came from the Viva board we assembled and utilized in class, two infrared sensors
// on the front of the car (these would also activate an LED on the board to display the 
// logic levels, when activated), and L298N Motor driver and a 7.4 2S LiPO rechargeable 
// battery.

#include <xc.h>
#include <pic16f1829.h>

#define _XTAL_FREQ 4000000  // 4 MHz Internal Oscillator

// === PPS Manual Definitions ===
#define RC5PPS  (*(volatile unsigned char*)0x220)  // RC5 PPS register
#define RC3PPS  (*(volatile unsigned char*)0x21E)  // RC3 PPS register

// === Function Prototypes ===
void setup(void);
void setup_pwm(void);
void motor_forward(void);
void motor_left(void);
void motor_right(void);
void motor_stop(void);

// === Main Program ===
void main(void) {
    setup();

    while (1) {
        unsigned char leftIR = PORTCbits.RC6;   // Left IR sensor (RC6)
        unsigned char rightIR = PORTAbits.RA5;  // Right IR sensor (RA5)

        if (leftIR == 0 && rightIR == 0) {
            motor_forward();
        }
        else if (leftIR == 1 && rightIR == 0) {
            motor_left();
        }
        else if (leftIR == 0 && rightIR == 1) {
            motor_right();
        }
        else {
            motor_stop();
        }
    }
}

// === Setup Function ===
void setup(void) {
    // Motor Inputs: Pins are on the TRIS# designations
    TRISC0 = 0; // IN1
    TRISC2 = 0; // IN2
    TRISA4 = 0; // IN3 (moved here from RC3)
    TRISC4 = 0; // IN4

    // IR Sensors : Pins are on the TRIS# designations
    TRISC6 = 1; // Left IR
    TRISA5 = 1; // Right IR

    // PWM outputs : Pins are on the TRIS# designations
    TRISC5 = 0; // ENA (Motor A PWM)
    TRISC3 = 0; // ENB (Motor B PWM)

    // Disable analog functions
    ANSELC = 0x00;
    ANSELA = 0x00;

    // Setup PWM and oscillator
    OSCCON = 0b01101010;  // 4 MHz internal
    LATC = 0x00;
    LATA = 0x00;

    setup_pwm();
}

// === PWM Configuration ===
void setup_pwm(void) {
    RC5PPS = 0x09;  // CCP1 to RC5 (Motor A)
    RC3PPS = 0x13;  // CCP2 to RC3 (Motor B)

    CCP1CON = 0b00001100; // PWM mode
    CCP2CON = 0b00001100;

    CCPR1L = 160;  // 50% duty cycle for Motor A
    CCPR2L = 160;  // 50% duty cycle for Motor B
    
    PR2 = 255;
    T2CON = 0b00000100;  // Timer2 ON, prescaler 1:1
    __delay_ms(10);
}

// === Motor Control ===
void motor_forward(void) {
    LATCbits.LATC0 = 1; LATCbits.LATC2 = 0;  // IN1/IN2
    LATAbits.LATA4 = 1; LATCbits.LATC4 = 0;  // IN3/IN4
}

void motor_left(void) {
    LATCbits.LATC0 = 0; LATCbits.LATC2 = 0;
    LATAbits.LATA4 = 1; LATCbits.LATC4 = 0;
}

void motor_right(void) {
    LATCbits.LATC0 = 1; LATCbits.LATC2 = 0;
    LATAbits.LATA4 = 0; LATCbits.LATC4 = 0;
}

void motor_stop(void) {
    LATCbits.LATC0 = 0; LATCbits.LATC2 = 0;
    LATAbits.LATA4 = 0; LATCbits.LATC4 = 0;
}
